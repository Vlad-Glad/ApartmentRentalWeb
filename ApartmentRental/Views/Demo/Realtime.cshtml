@{
    ViewData["Title"] = "Realtime Demo";
}

<div class="container my-4">
    <div class="d-flex justify-content-between align-items-start gap-3 mb-3">
        <div>
            <h1 class="h3 mb-1">Realtime Demo</h1>
            <div class="text-muted">
                Compare Polling, Long Polling and SignalR for the same "change event".
                Open this page in two tabs to see realtime delivery.
            </div>
        </div>
    </div>

    <div class="card app-card mb-3">
        <div class="card-body d-flex flex-wrap gap-3 align-items-end">
            <div style="min-width: 240px;">
                <label class="form-label">Mode</label>
                <select id="mode" class="form-select">
                    <option value="polling">Polling (5s)</option>
                    <option value="longpoll">Long polling</option>
                    <option value="signalr">SignalR</option>
                </select>
            </div>

            <div>
                <label class="form-label d-block">Control</label>
                <div class="btn-group" role="group" aria-label="Realtime controls">
                    <button id="btnStart" type="button" class="btn btn-primary">Start</button>
                    <button id="btnStop" type="button" class="btn btn-outline-secondary" disabled>Stop</button>
                </div>

                <div class="btn-group ms-2" role="group" aria-label="Demo actions">
                    <button id="btnTrigger" type="button" class="btn btn-warning">Trigger change</button>
                    <button id="btnReset" type="button" class="btn btn-outline-danger">Reset demo (dev)</button>
                </div>
            </div>

            <div class="ms-auto text-end">
                <div class="small text-muted">Current version</div>
                <div class="h5 mb-0" id="currentVersion">-</div>
            </div>
        </div>
    </div>

    <div class="card app-card">
        <div class="card-body">
            <div class="row g-3">
                <div class="col-md-3">
                    <div class="small text-muted">HTTP requests</div>
                    <div class="h4 mb-0" id="reqCount">0</div>
                </div>
                <div class="col-md-3">
                    <div class="small text-muted">Updates received</div>
                    <div class="h4 mb-0" id="updCount">0</div>
                </div>
                <div class="col-md-3">
                    <div class="small text-muted">Last delay (ms)</div>
                    <div class="h4 mb-0" id="lastDelay">-</div>
                </div>
                <div class="col-md-3">
                    <div class="small text-muted">Status</div>
                    <div class="h6 mb-0" id="statusText">Idle</div>
                </div>
            </div>

            <hr />

            <pre class="mb-0 small" id="log" style="max-height: 280px; overflow:auto;"></pre>
        </div>
    </div>
</div>

@section Scripts {
    <script src="~/lib/microsoft/signalr/dist/browser/signalr.min.js"></script>

    <script>
        const els = {
            mode: document.getElementById("mode"),
            start: document.getElementById("btnStart"),
            stop: document.getElementById("btnStop"),
            trigger: document.getElementById("btnTrigger"),
            reset: document.getElementById("btnReset"),
            req: document.getElementById("reqCount"),
            upd: document.getElementById("updCount"),
            delay: document.getElementById("lastDelay"),
            status: document.getElementById("statusText"),
            version: document.getElementById("currentVersion"),
            log: document.getElementById("log")
        };

        let running = false;
        let reqCount = 0;
        let updCount = 0;
        let currentVersion = 0;

        let pollTimer = null;
        let abortController = null;
        let hubConnection = null;

        function logLine(msg) {
            const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
            els.log.textContent = line + els.log.textContent;
        }

        function setStatus(s) { els.status.textContent = s; }

        function bumpReq() {
            reqCount++;
            els.req.textContent = String(reqCount);
        }

        function setVersion(v) {
            currentVersion = v;
            els.version.textContent = v > 0 ? String(v) : "-";
        }

        function resetUiCounters() {
            reqCount = 0;
            updCount = 0;
            setVersion(0);

            els.req.textContent = "0";
            els.upd.textContent = "0";
            els.delay.textContent = "-";
            els.log.textContent = "";
        }

        function onUpdate(version, updatedAtUtc) {
            updCount++;
            els.upd.textContent = String(updCount);

            setVersion(version);

            const updated = Date.parse(updatedAtUtc);
            const now = Date.now();
            const delayMs = isNaN(updated) ? "-" : String(Math.max(0, now - updated));

            els.delay.textContent = delayMs;
            logLine(`Update received. version=${version}, delayMs=${delayMs}`);
        }

        async function httpGetJson(url) {
            bumpReq();
            const res = await fetch(url, { cache: "no-store" });
            if (res.status === 204) return null;
            if (!res.ok) throw new Error("HTTP " + res.status);
            return await res.json();
        }

        async function loadInitialState() {
            try {
                const s = await httpGetJson("/api/realtime/state");
                if (s) {
                    // do NOT count as update received; only set baseline
                    setVersion(s.version);
                    logLine(`Initial state loaded. version=${s.version}`);
                }
            } catch (e) {
                logLine("Init error: " + e.message);
            }
        }

        async function startPolling() {
            setStatus("Polling started (5s)");
            logLine("Mode: polling");

            await loadInitialState();

            pollTimer = setInterval(async () => {
                if (!running) return;
                try {
                    const s = await httpGetJson("/api/realtime/state");
                    if (s && s.version !== currentVersion) onUpdate(s.version, s.updatedAtUtc);
                } catch (e) {
                    logLine("Polling error: " + e.message);
                }
            }, 5000);
        }

        async function startLongPoll() {
            setStatus("Long polling started");
            logLine("Mode: longpoll");

            await loadInitialState();

            abortController = new AbortController();

            while (running) {
                try {
                    bumpReq();
                    const res = await fetch(`/api/realtime/longpoll?since=${currentVersion}&timeoutMs=25000`, {
                        cache: "no-store",
                        signal: abortController.signal
                    });

                    if (res.status === 204) {
                        // timed out, loop again
                        continue;
                    }

                    if (!res.ok) {
                        logLine("Longpoll HTTP error: " + res.status);
                        await new Promise(r => setTimeout(r, 800));
                        continue;
                    }

                    const s = await res.json();
                    if (s && s.version !== currentVersion) onUpdate(s.version, s.updatedAtUtc);
                } catch (e) {
                    if (!running) break;
                    logLine("Longpoll error: " + (e.message || e));
                    await new Promise(r => setTimeout(r, 800));
                }
            }
        }

        async function startSignalR() {
            if (!window.signalR) {
                setStatus("SignalR client library is missing");
                logLine("SignalR client library is not loaded.");
                return;
            }

            setStatus("SignalR connecting...");
            logLine("Mode: signalr");

            hubConnection = new signalR.HubConnectionBuilder()
                .withUrl("/hubs/demo") // IMPORTANT: must match app.MapHub<DemoHub>("/hubs/demo")
                .withAutomaticReconnect()
                .build();

            hubConnection.on("demoChanged", payload => {
                if (!payload) return;
                onUpdate(payload.version, payload.updatedAtUtc);
            });

            hubConnection.onreconnecting(() => setStatus("SignalR reconnecting..."));
            hubConnection.onreconnected(() => setStatus("SignalR connected"));
            hubConnection.onclose(() => setStatus("SignalR disconnected"));

            await hubConnection.start();
            setStatus("SignalR connected");
            logLine("SignalR connected");

            await loadInitialState();
        }

        async function start() {
            if (running) return;

            running = true;
            els.start.disabled = true;
            els.stop.disabled = false;

            resetUiCounters();

            const mode = els.mode.value;

            if (mode === "polling") await startPolling();
            else if (mode === "longpoll") await startLongPoll();
            else if (mode === "signalr") await startSignalR();
        }

        async function stop() {
            if (!running) return;

            running = false;
            els.start.disabled = false;
            els.stop.disabled = true;

            if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }

            if (abortController) { abortController.abort(); abortController = null; }

            if (hubConnection) {
                try { await hubConnection.stop(); } catch { }
                hubConnection = null;
            }

            setStatus("Stopped");
            logLine("Stopped");
        }

        els.start.addEventListener("click", start);
        els.stop.addEventListener("click", stop);

        els.trigger.addEventListener("click", async () => {
            try {
                bumpReq();
                const res = await fetch("/api/realtime/trigger", { method: "POST", cache: "no-store" });
                if (!res.ok) throw new Error("HTTP " + res.status);

                const s = await res.json();
                logLine("Triggered change. serverVersion=" + s.version);
            } catch (e) {
                logLine("Trigger error: " + e.message);
            }
        });

        els.reset.addEventListener("click", async () => {
            try {
                bumpReq();
                const res = await fetch("/api/realtime/reset", { method: "POST", cache: "no-store" });
                if (!res.ok) throw new Error("HTTP " + res.status);

                const s = await res.json();

                // Reset local baseline too (important if polling is stopped)
                resetUiCounters();
                setStatus("Idle");
                logLine("Reset done. serverVersion=" + s.version);
            } catch (e) {
                logLine("Reset error: " + e.message);
            }
        });

        // On page unload, stop background loops
        window.addEventListener("beforeunload", () => {
            try { stop(); } catch { }
        });
    </script>
}
