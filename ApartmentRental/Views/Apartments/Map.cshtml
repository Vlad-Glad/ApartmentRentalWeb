@{
    ViewData["Title"] = "Apartments on map";
}

<div class="container my-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div>
            <h1 class="h3 mb-1">Apartments on map</h1>
            <div class="app-muted">Filter by city and explore listings.</div>
        </div>
        <a asp-action="Index" class="btn btn-outline-secondary app-pill">
            <i class="bi bi-arrow-left me-1"></i> Back
        </a>
    </div>

    <div class="card app-card mb-3">
        <div class="card-body">
            <label for="cityFilter" class="form-label">City filter</label>
            <select id="cityFilter" class="form-select">
                <option value="">All cities</option>
            </select>
        </div>
    </div>

    <div class="card app-card">
        <div class="card-body p-0 position-relative">
            <div id="apartments-map" class="border rounded" style="height: 540px;"></div>

            <!-- Stats overlay -->
            <div class="position-absolute top-0 end-0 p-3" style="z-index: 1000; width: 360px;">
                <div class="card app-card shadow-sm">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <div>
                                <div class="fw-semibold">Apartments by city</div>
                                <div class="text-muted small" id="totalApartmentsText">Loading...</div>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-secondary" id="refreshStatsBtn">
                                Refresh
                            </button>
                        </div>

                        <canvas id="cityChart" height="180"></canvas>

                        <div class="text-muted small mt-2">
                            Top 10 cities by number of listings.
                        </div>
                    </div>
                </div>
            </div>

            <!-- No results label -->
            <div id="noResultsBadge"
                 class="position-absolute bottom-0 start-0 m-3 px-3 py-2 bg-white border rounded shadow-sm d-none"
                 style="z-index: 1000;">
                <span class="text-muted">No apartments found for the selected filter.</span>
            </div>
        </div>
    </div>
</div>

@section Head {
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
}

@section Scripts {
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <script src="~/lib/microsoft/signalr/dist/browser/signalr.min.js"></script>


    <script>
        function escapeHtml(str) {
            return String(str ?? "")
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll('"', "&quot;")
                .replaceAll("'", "&#039;");
        }

        function setNoResultsVisible(isVisible) {
            const el = document.getElementById("noResultsBadge");
            if (!el) return;
            el.classList.toggle("d-none", !isVisible);
        }

        function normalizeCity(value) {
            return String(value ?? "").trim();
        }

        document.addEventListener("DOMContentLoaded", () => {
            const state = {
                map: null,
                markers: [],
                allApartments: [],
                chart: null,
                connection: null,
                refreshTimer: null,
                isRefreshing: false,
                citiesLoadedOnce: false
            };

            const cityFilterEl = document.getElementById("cityFilter");
            const refreshStatsBtn = document.getElementById("refreshStatsBtn");

            initMap(state);
            wireEvents(state);

            // Initial load
            refreshAll(state).catch(err => console.error(err));

            // Real-time
            initRealtime(state).catch(err => console.error(err));

            function initMap(state) {
                state.map = L.map("apartments-map").setView([49.0, 31.0], 6);

                L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                    maxZoom: 19,
                    attribution: "&copy; OpenStreetMap contributors"
                }).addTo(state.map);
            }

            function wireEvents(state) {
                cityFilterEl.addEventListener("change", async () => {
                    // Render markers immediately
                    renderMarkers(state);

                    // Optional: group subscription by city (safe if hub methods exist)
                    await tryUpdateCityGroup(state);
                });

                refreshStatsBtn.addEventListener("click", () => refreshAll(state));
            }

            async function refreshAll(state) {
                if (state.isRefreshing) return;
                state.isRefreshing = true;

                try {
                    await loadApartments(state);
                    await loadStats(state);
                } finally {
                    state.isRefreshing = false;
                }
            }

            // Debounced refresh on SignalR events (prevents spam)
            function scheduleRefresh(state) {
                if (state.refreshTimer) clearTimeout(state.refreshTimer);
                state.refreshTimer = setTimeout(() => {
                    refreshAll(state).catch(err => console.error(err));
                }, 300);
            }

            async function loadApartments(state) {
                const selectedCityBefore = normalizeCity(cityFilterEl.value);

                // If you can exceed 100 apartments, create a dedicated endpoint for the map.
                const res = await fetch("/api/apartments?skip=0&limit=100", { cache: "no-store" });
                if (!res.ok) {
                    console.error("Failed to load apartments. HTTP:", res.status);
                    state.allApartments = [];
                    populateCityFilter(state, selectedCityBefore);
                    renderMarkers(state);
                    return;
                }

                const payload = await res.json();
                state.allApartments = payload.items || [];

                populateCityFilter(state, selectedCityBefore);
                renderMarkers(state);
            }

            function populateCityFilter(state, selectedCityToKeep) {
                const selected = normalizeCity(selectedCityToKeep);

                // Build city set from data
                const cities = [...new Set(
                    state.allApartments
                        .map(a => normalizeCity(a.city))
                        .filter(x => x.length > 0)
                )].sort((a, b) => a.localeCompare(b));

                // Rebuild dropdown but keep "All cities"
                cityFilterEl.querySelectorAll("option:not([value=''])").forEach(o => o.remove());

                for (const city of cities) {
                    const opt = document.createElement("option");
                    opt.value = city;
                    opt.textContent = city;
                    cityFilterEl.appendChild(opt);
                }

                // Restore selection if still available
                if (selected && cities.includes(selected)) {
                    cityFilterEl.value = selected;
                } else {
                    // keep All cities
                    cityFilterEl.value = "";
                }
            }

            function clearMarkers(state) {
                for (const m of state.markers) {
                    state.map.removeLayer(m);
                }
                state.markers = [];
            }

            function renderMarkers(state) {
                clearMarkers(state);

                const selectedCity = normalizeCity(cityFilterEl.value);

                const filtered = state.allApartments.filter(a => {
                    if (selectedCity && normalizeCity(a.city) !== selectedCity) return false;
                    return a.latitude != null && a.longitude != null;
                });

                setNoResultsVisible(filtered.length === 0);
                if (filtered.length === 0) return;

                const bounds = [];

                for (const a of filtered) {
                    const lat = a.latitude;
                    const lng = a.longitude;

                    const title = escapeHtml(a.title || "Apartment");
                    const city = escapeHtml(a.city || "");
                    const price = escapeHtml(a.price);

                    const popupHtml = `
                        <div>
                            <strong>${title}</strong><br/>
                            ${city}<br/>
                            Price: ${price} $/month<br/>
                            <a href="/Apartments/Landing/${a.id}">View</a>
                        </div>
                    `;

                    const marker = L.marker([lat, lng]).addTo(state.map);
                    marker.bindPopup(popupHtml);

                    state.markers.push(marker);
                    bounds.push([lat, lng]);
                }

                if (bounds.length > 0) {
                    state.map.fitBounds(bounds, { padding: [30, 30] });
                }
            }

            async function loadStats(state) {
                const totalText = document.getElementById("totalApartmentsText");

                try {
                    totalText.textContent = "Loading...";

                    const res = await fetch("/api/stats/apartments", { cache: "no-store" });
                    if (!res.ok) throw new Error("Stats request failed. HTTP: " + res.status);

                    const data = await res.json();

                    totalText.textContent = `Total apartments: ${data.totalApartments}`;

                    const labels = (data.byCity || []).map(x => x.city);
                    const counts = (data.byCity || []).map(x => x.count);

                    const ctx = document.getElementById("cityChart");

                    if (state.chart) {
                        state.chart.destroy();
                        state.chart = null;
                    }

                    state.chart = new Chart(ctx, {
                        type: "bar",
                        data: {
                            labels,
                            datasets: [{
                                label: "Listings",
                                data: counts
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { display: false } },
                            scales: { y: { beginAtZero: true } }
                        }
                    });
                } catch (e) {
                    console.error(e);
                    totalText.textContent = "Stats are temporarily unavailable.";
                }
            }

            async function initRealtime(state) {
                if (typeof signalR === "undefined") {
                    console.warn("SignalR client library is not loaded.");
                    return;
                }

                const connection = new signalR.HubConnectionBuilder()
                    .withUrl("/hubs/apartments")
                    .withAutomaticReconnect()
                    .build();

                connection.on("apartmentChanged", (payload) => {
                    console.log("apartmentChanged:", payload);
                    scheduleRefresh(state);
                });

                connection.onreconnecting((err) => console.warn("SignalR reconnecting...", err));
                connection.onreconnected(() => console.info("SignalR reconnected."));
                connection.onclose((err) => console.warn("SignalR closed.", err));

                await connection.start();
                console.info("SignalR connected.");

                state.connection = connection;

                // Join group for initial city (if any and if hub supports it)
                await tryUpdateCityGroup(state);
            }

            async function tryUpdateCityGroup(state) {
                if (!state.connection) return;

                const selectedCity = normalizeCity(cityFilterEl.value);

                // If you implemented JoinCity/LeaveCity in hub, this will work.
                // If not implemented, we catch and ignore.
                try {
                    if (state.currentCityGroup) {
                        await state.connection.invoke("LeaveCity", state.currentCityGroup);
                    }
                } catch (e) {
                    // ignore if method doesn't exist
                }

                state.currentCityGroup = selectedCity || "";

                if (!state.currentCityGroup) return;

                try {
                    await state.connection.invoke("JoinCity", state.currentCityGroup);
                } catch (e) {
                    // ignore if method doesn't exist
                }
            }
        });
    </script>
}
